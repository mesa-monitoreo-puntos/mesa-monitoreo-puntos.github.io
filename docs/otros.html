<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>SIMOCUTE - Mesa de Monitoreo por Puntos - Otros recursos</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./img/rwds-favicon.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>


<link rel="stylesheet" href="mmpp.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./img/logo-mmpp.png" alt="SIMOCUTE - Mesa de Monitoreo por Puntos" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./evm/index.html"> 
<span class="menu-text">Evaluación Visual Multitemporal</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./evm-casos-estudio/index.html"> 
<span class="menu-text">Casos de estudio</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Otros recursos</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<ol type="1">
<li>Malla de Puntos del SIMOCUTE</li>
</ol>
<p>La Malla de Puntos N1 del SIMOCUTE y sus densificaciones N2 y N3</p>
<p>Las mallas de puntos son un arreglo que forma hexágonos de 7 puntos que surgen de la necesidad de geolocalizar ubicaciones de forma sistemática que ayuden al monitoreo de los usos y coberturas de la tierra en Costa Rica. La malla principal a partir de las cuales surgen los niveles de mayor densidad de puntos proviene del arreglo sistemático del Inventario Forestal Nacional de 2013-2014 que lideró SINAC. La diferencia en distancia de los puntos de la malla original es de 2402.81m, reduciéndose a la mitad conforme se intensifican las mallas.</p>
<p><a href="documents/Prop_dens_Mallas_Dic_2019_sub_sub_mesa.pdf">Método de construción y densificación de las mallas</a><br>
</p>
<ol start="2" type="1">
<li>Sistema de Clasificación del SIMOCUTE Versión 2.1</li>
</ol>
<p>El objetivo general del SIMOCUTE es dar a conocer el estado actual y los cambios de la cobertura y uso de la tierra, así como de los ecosistemas, y proporcionar información periódica que permita evaluar el estado de los recursos del medio ambiente. Para cumplir esta meta se requiere, entre otras cosas, de la estandarización de metodologías, protocolos y otras herramientas para monitorear la cobertura y el uso de la tierra y los ecosistemas. Se ha identificado que para cumplir con los objetivos propuestos para el SIMOCUTE se requiere de un sistema de clasificación de uso y cobertura de la tierra (SICUCT) que permita la operación de un sistema robusto y transparente de monitoreo. Este sistema de clasificación es la agrupación de entidades similares en grupos o clases basadas en características comunes para la cobertura y uso de la tierra, con las definiciones clave asociadas.</p>
<p>La clasificación es uno de los componentes más importantes del SIMOCUTE. Responde a la pregunta “¿qué es?” y determina las definiciones y claves asociadas para realizar los procesos de monitoreo. La labor consiste en la construcción y mejora continua de un sistema de clasificación armonizado del territorio costarricense.</p>
<p>Los sistemas de clasificación del SIMOCUTE cumplen las siguientes características:</p>
<ul>
<li>Exhaustivo</li>
<li>Mutualmente Excluyente</li>
<li>Jerárquico</li>
<li>Robusto</li>
<li>Transparente</li>
<li>Dinámico</li>
</ul>
<p>El uso de la tierra se define como “descripción del uso funcional de un sitio, tal y como elementos biofísicos y culturales”. Por ejemplo, pastos, plantaciones, forestales, café, bosques, etc. El uso de la tierra requiere una perspectiva humana, la interpretación de las actividades, tiene una superficie mínima asociada y en ocasiones se requiere observación in situ.</p>
<p>La cobertura de la tierra, corresponde a la cubierta biofísica presente en un sitio con sus elementos naturales y antrópicos. En este caso no requiere de análisis de contexto o inferencia del entorno, y no tiene un área mínima asociada a ella.</p>
<p><a href="documents/ManualClasificacionUsoyCoberturaTierraCR _version 1.1.pdf">Sistema de Clasificación de Cobertura y Uso de la tierra del SIMOCUTE</a><br>
</p>
<ol start="3" type="1">
<li>Página del SIMOCUTE</li>
</ol>
<p>El SIMOCUTE es la plataforma oficial de coordinación, vinculación e integración institucional y sectorial del Estado costarricense, para facilitar la gestión y distribución del conocimiento e información en materia de cobertura y uso de la tierra y ecosistemas, integrado al Sistema Nacional de Información Ambiental (SINIA) del MINAE y vinculado oficialmente con el Sistema Nacional de Información Territorial (SNIT) del IGN del Registro Nacional.</p>
<p>El objetivo general del SIMOCUTE es dar a conocer el estado actual y los cambios de la cobertura y uso de la tierra, así como de los ecosistemas mediante el monitoreo, para proporcionar información periódica que permita evaluar el estado de los recursos del ambiente. Lo anterior para facilitar la toma de decisiones políticas informadas para promover el uso racional de la tierra y mantener la calidad e integridad de los ecosistemas y el ambiente para las generaciones futuras, así como para responder a compromisos nacionales e internacionales de información</p>
<p>Artículos 2 y 5 del Decreto Ejecutivo N° 42886-MINAE-MAG-JP</p>
<p><a href="https://https://simocute.go.cr/home">Link a la página del SIMOCUTE</a><br>
</p>
<ol start="4" type="1">
<li>Link a manuales y recursos de R y Rstudio</li>
</ol>
<p>R es un lenguaje de programación enfocado en análisis estadístico. Es ampliamente utilizado en diversas áreas de investigación, entre las que pueden mencionarse ciencia de datos (data science), big data y aprendizaje automático (machine learning). Fue creado por Ross Ihaka y Robert Gentleman en la Universidad de Auckland, Nueva Zelanda, en 1993.</p>
<p>R es un proyecto de software libre que se comparte mediante una licencia GNU General Public Licence (GNU GPL). Esta característica permite que la funcionalidad original de R pueda ser ampliada mediante bibliotecas o paquetes desarrollados por la comunidad de programadores.</p>
<p>Para programar en R, puede utilizarse una interfaz de línea de comandos, editores de texto (ej. Visual Studio Code, Vim) y también ambientes de desarrollo integrados (IDE, integrated development environment) como Jupyter o RStudio.</p>
<p>RStudio es un entorno de desarrollo integrado (IDE) para R y Python. Incluye una consola, un editor de resaltado de sintaxis que admite la ejecución directa de código y herramientas para el trazado, el historial, la depuración y la gestión del espacio de trabajo. RStudio está disponible en ediciones comerciales y de código abierto y se ejecuta en el escritorio (Windows, Mac y Linux).</p>
<p><a href="https://mesa-monitoreo-puntos.github.io/capacitacion/">Link a la página de Capacitación del SIMOCUTE</a><br>
<a href="https://posit.co/products/open-source/rstudio/">Link a la página de RStudio</a><br>
</p>
<ol start="5" type="1">
<li>Link a páginas de descarga de CEO y CED</li>
</ol>
<p>Open Foris es un conjunto de herramientas de software gratuitas y de código abierto que facilita la recopilación, el análisis y la generación de informes de datos de manera flexible y eficiente. https://openforis.org/</p>
<p>Entre las herramientas desarrolladas por Open Foris, se encuentra Collect Earth que permite la recopilación de datos a través de imágenes satelitales de alta y muy alta resolución para una amplia variedad de propósitos, que incluyen:</p>
<p>Apoyar inventarios forestales nacionales de varias fases Evaluaciones de uso de la tierra, cambio de uso de la tierra y silvicultura (UTCUTS) Seguimiento de terrenos agrícolas y zonas urbanas Validación de mapas existentes Recopilación de datos socioeconómicos espacialmente explícitos Cuantificación de la deforestación, la reforestación y la desertificación.</p>
<p><a href="https://www.collect.earth/">Link CEO</a><br>
<a href="https://openforis.org/tools/collect-earth/">Link CED</a><br>
</p>
<ol start="6" type="1">
<li>Link a página de descarga de QGIS</li>
</ol>
<p>QGIS (anteriormente llamado también Quantum GIS) es un Sistema de Información Geográfica (SIG) de software libre y de código abierto para plataformas GNU/Linux, Unix, Mac OS, Microsoft Windows y Android.2 Fue uno de los primeros ocho proyectos de la Fundación OSGeo y en 2008 oficialmente superó la fase de incubación. Permite manejar formatos raster y vectoriales a través de la biblioteca GDAL (GADL/OGR), así como bases de datos. Algunas de sus características son:</p>
<p>Soporte para la extensión espacial de PostgreSQL, PostGIS. Manejo de archivos vectoriales Shapefile, ArcInfo coverages, MapInfo, GRASS GIS, DXF, etc. Soporte para un importante número de tipos de archivos ráster (GRASS GIS, GeoTIFF, TIFF, JPG, etc.)</p>
<p>Una de sus mayores ventajas es la posibilidad de usar Quantum GIS como GUI (Interfaz gráfica de usuario) del SIG GRASS, utilizando toda la potencia de análisis de este último en un entorno de trabajo más amigable. QGIS está desarrollado en C++, usando la biblioteca Qt para su Interfaz gráfica de usuario.</p>
<p>https://es.wikipedia.org/wiki/QGIS 20/02/2023</p>
<p><a href="https://qgis.org/es/site/forusers/download.html">Link de descarga QGIS</a><br>
</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>